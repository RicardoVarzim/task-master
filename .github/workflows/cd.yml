name: CD

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - 'docs/**'

jobs:
  build-msix:
    name: Build MSIX Package
    runs-on: windows-latest
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      is-release: ${{ steps.version.outputs.is-release }}
      tag-name: ${{ steps.version.outputs.tag-name }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Needed for tag detection
    
    - name: Extract version from tag
      id: version
      shell: pwsh
      run: |
        if ($env:GITHUB_REF -like 'refs/tags/v*') {
          $tagName = $env:GITHUB_REF -replace 'refs/tags/', ''
          $version = $tagName -replace '^v', ''
          Write-Host "Tag detected: $tagName"
          Write-Host "Version: $version"
          Write-Host "version=$version" >> $env:GITHUB_OUTPUT
          Write-Host "is-release=true" >> $env:GITHUB_OUTPUT
          Write-Host "tag-name=$tagName" >> $env:GITHUB_OUTPUT
        } else {
          # Use version from manifest or default
          $manifestPath = "src\TaskMaster.Host\Package.appxmanifest"
          if (Test-Path $manifestPath) {
            $manifest = [xml](Get-Content $manifestPath)
            $version = $manifest.Package.Identity.Version
          } else {
            $version = "1.0.0.0"
          }
          Write-Host "No tag detected, using version: $version"
          Write-Host "version=$version" >> $env:GITHUB_OUTPUT
          Write-Host "is-release=false" >> $env:GITHUB_OUTPUT
          Write-Host "tag-name=" >> $env:GITHUB_OUTPUT
        }
      env:
        GITHUB_REF: ${{ github.ref }}
    
    - name: Setup .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
    
    - name: Verify Windows SDK Installation
      shell: pwsh
      run: |
        $ErrorActionPreference = "Continue"
        Write-Host "Checking for Windows SDK installation..."
        
        # Check common Windows SDK locations (GitHub Actions runners usually have it pre-installed)
        $sdkPaths = @(
          "${env:ProgramFiles(x86)}\Windows Kits\10\bin",
          "${env:ProgramFiles}\Windows Kits\10\bin",
          "${env:ProgramFiles(x86)}\Windows Kits\10\App Certification Kit",
          "${env:ProgramFiles}\Windows Kits\10\App Certification Kit"
        )
        
        Write-Host "Checking SDK paths..."
        foreach ($path in $sdkPaths) {
          if (Test-Path $path) {
            Write-Host "  Found: $path"
          }
        }
        
        # Search for MakeAppx.exe recursively in common locations
        $makeAppx = $null
        $searchPaths = @(
          "${env:ProgramFiles(x86)}\Windows Kits",
          "${env:ProgramFiles}\Windows Kits"
        )
        
        foreach ($searchPath in $searchPaths) {
          if (Test-Path $searchPath) {
            Write-Host "Searching in: $searchPath"
            $makeAppx = Get-ChildItem -Path $searchPath -Filter "MakeAppx.exe" -Recurse -ErrorAction SilentlyContinue | 
              Sort-Object FullName -Descending | 
              Select-Object -First 1
            if ($makeAppx) {
              Write-Host "‚úì MakeAppx.exe found at: $($makeAppx.FullName)"
              break
            }
          }
        }
        
        if (-not $makeAppx) {
          Write-Host "MakeAppx.exe not found. Checking PATH..."
          $makeAppxInPath = Get-Command MakeAppx.exe -ErrorAction SilentlyContinue
          if ($makeAppxInPath) {
            Write-Host "‚úì MakeAppx.exe found in PATH: $($makeAppxInPath.Source)"
          } else {
            Write-Host "‚ö† MakeAppx.exe not found. The script will try to find it during build."
            Write-Host "Windows SDK may need to be installed. Listing available SDK components:"
            if (Test-Path "${env:ProgramFiles(x86)}\Windows Kits") {
              Get-ChildItem -Path "${env:ProgramFiles(x86)}\Windows Kits" -Directory -ErrorAction SilentlyContinue | ForEach-Object {
                Write-Host "  - $($_.FullName)"
              }
            }
          }
        }
        
        # Verify SignTool as well
        $signTool = $null
        foreach ($searchPath in $searchPaths) {
          if (Test-Path $searchPath) {
            $signTool = Get-ChildItem -Path $searchPath -Filter "signtool.exe" -Recurse -ErrorAction SilentlyContinue | 
              Sort-Object FullName -Descending | 
              Select-Object -First 1
            if ($signTool) {
              Write-Host "‚úì SignTool.exe found at: $($signTool.FullName)"
              break
            }
          }
        }
        
        if (-not $signTool) {
          Write-Host "‚ö† SignTool.exe not found. Package may not be signed, but build will continue."
        }
    
    - name: Build MSIX Package
      shell: pwsh
      run: |
        $ErrorActionPreference = "Stop"
        Write-Host "Current directory: $(Get-Location)"
        Write-Host "Script path: $PSScriptRoot"
        
        if (-not (Test-Path ".\scripts\build-msix.ps1")) {
          Write-Error "build-msix.ps1 not found at .\scripts\build-msix.ps1"
          Get-ChildItem -Recurse -Filter "build-msix.ps1" | ForEach-Object { Write-Host "Found at: $($_.FullName)" }
          exit 1
        }
        
        .\scripts\build-msix.ps1 -Configuration Release -OutputPath ".\dist\msix"
    
    - name: Upload MSIX Artifact
      uses: actions/upload-artifact@v4
      with:
        name: taskmaster-msix
        path: dist/msix/*.msix
        retention-days: 90
    
    - name: Upload Certificate
      uses: actions/upload-artifact@v4
      with:
        name: taskmaster-certificate
        path: dist/msix/*.cer
        retention-days: 90
        if-no-files-found: warn
    
    - name: Create GitHub Release
      if: steps.version.outputs.is-release == 'true'
      uses: softprops/action-gh-release@v1
      with:
        files: |
          dist/msix/*.msix
          dist/msix/*.cer
        tag_name: ${{ steps.version.outputs.tag-name }}
        name: Task Master ${{ steps.version.outputs.tag-name }}
        body: |
          ## Task Master ${{ steps.version.outputs.tag-name }}
          
          **Version:** ${{ steps.version.outputs.version }}
          **Build:** #${{ github.run_number }}
          **Commit:** [${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }})
          
          ### üì¶ Installation Instructions
          
          1. **Download the certificate** (`TaskMasterDemo.cer`)
          2. **Install the certificate:**
             - Right-click on `TaskMasterDemo.cer` ‚Üí **Install Certificate**
             - Select **Local Machine** ‚Üí **Next**
             - Choose **Place all certificates in the following store**
             - Click **Browse** ‚Üí Select **Trusted Root Certification Authorities** ‚Üí **OK**
             - Click **Next** ‚Üí **Finish**
          3. **Install the MSIX package:**
             - Double-click `TaskMaster_${{ steps.version.outputs.version }}_x64.msix`
             - Follow the installation wizard
          
          ### üìã Files Included
          
          - **MSIX Package:** `TaskMaster_${{ steps.version.outputs.version }}_x64.msix`
          - **Certificate:** `TaskMasterDemo.cer` (required for installation)
          
          ### ‚ö†Ô∏è Important Notes
          
          - This is a self-signed certificate for development/testing purposes
          - The certificate must be installed before installing the MSIX package
          - For production releases, a proper code signing certificate should be used
          
          ### üîß System Requirements
          
          - Windows 10 version 1809 (build 17763) or later
          - Windows 11
          
          ---
          
          **Full Changelog:** https://github.com/${{ github.repository }}/compare/${{ github.event.before }}...${{ github.sha }}
        draft: false
        prerelease: ${{ contains(steps.version.outputs.tag-name, 'alpha') || contains(steps.version.outputs.tag-name, 'beta') || contains(steps.version.outputs.tag-name, 'rc') }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

